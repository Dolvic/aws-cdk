import { Construct } from 'constructs';
import { AddStageOpts, AddWaveOptions, Blueprint, Step } from '../blueprint';
import { IDeploymentEngine } from './engine';

// v2 - keep this import as a separate section to reduce merge conflict when forward merging with the v2 branch.
// eslint-disable-next-line
import { Aspects, Construct as CoreConstruct, Stage } from '@aws-cdk/core';

/**
 * Properties for a `Pipeline`
 */
export interface PipelineProps {
  /**
   * The build step that produces the CDK Cloud Assembly
   *
   * The primary output of this step needs to be the `cdk.out` directory
   * generated by the `cdk synth` command.
   *
   * If you use `SynthStep`, the output directory will automatically be
   * configured correctly; if you use a different kind of `Step`, you
   * may need to configure it explicitly.
   */
  readonly synthStep: Step;

  /**
   * The deployment engine
   *
   * This controls what deployment system will be used to deploy this
   * pipeline.
   *
   * Right now, only `new CodePipelineEngine()` is supported in this library,
   * though 3rd implementations may be available.
   *
   * The engine is invoked when `buildPipeline()` is called, or when
   * `app.synth()` is called (whichever happens first).
   */
  readonly engine: IDeploymentEngine;
}

/**
 * A generic CDK Pipelines pipeline
 *
 * The Pipeline should receive an Engine which builds actual infrastructure from
 * the pipeline definition.
 *
 * The actual pipeline infrastructure is constructed (by invoking the engine)
 * when `buildPipeline()` is called, or when `app.synth()` is called (whichever
 * happens first).
 */
export class Pipeline extends CoreConstruct {
  private readonly blueprint: Blueprint;
  private readonly engine: IDeploymentEngine;
  private built = false;

  constructor(scope: Construct, id: string, props: PipelineProps) {
    super(scope, id);

    if (!props.synthStep.primaryOutput) {
      throw new Error(`synthStep ${props.synthStep} must produce a primary output, but is not producing anything. Configure the Step differently or use a different Step type.`);
    }

    this.engine = props.engine;
    this.blueprint = new Blueprint({
      synthStep: props.synthStep,
    });

    Aspects.of(this).add({ visit: () => this.buildJustInTime() });
  }

  /**
   * Deploy a single Stage by itself
   *
   * Add a Stage to the pipeline, to be deployed in sequence with other
   * Stages added to the pipeline. All Stacks in the stage will be deployed
   * in an order automatically determined by their relative dependencies.
   */
  public addStage(stage: Stage, options?: AddStageOpts) {
    if (this.built) {
      throw new Error('addStage: can\'t add Stages anymore after build() has been called');
    }

    return this.blueprint.addStage(stage, options);
  }

  /**
   * Add a Wave to the pipeline, for deploying multiple Stages in parallel
   *
   * Use the return object of this method to deploy multiple stages in parallel.
   *
   * Example:
   *
   * ```ts
   * const wave = pipeline.addWave('MyWave');
   * wave.addStage(new MyStage('Stage1', ...));
   * wave.addStage(new MyStage('Stage2', ...));
   * ```
   */
  public addWave(id: string, options?: AddWaveOptions) {
    if (this.built) {
      throw new Error('addStage: can\'t add Stages anymore after build() has been called');
    }

    return this.blueprint.addWave(id, options);
  }

  /**
   * Send the current pipeline definition to the engine, and construct the pipeline
   *
   * It is not possible to modify the pipeline after calling this method.
   */
  public buildPipeline() {
    if (this.built) {
      throw new Error('build() has already been called: can only call it once');
    }
    this.engine.buildDeployment({ blueprint: this.blueprint, scope: this });
    this.built = true;
  }

  /**
   * Automatically call 'build()' just before synthesis if the user hasn't explicitly called it yet
   */
  private buildJustInTime() {
    if (!this.built) {
      this.buildPipeline();
    }
  }
}